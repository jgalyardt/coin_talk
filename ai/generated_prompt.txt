I am creating an Elixir Phoenix back-end for a Vue 3 front-end called coin_talk.
The concept is two charts on the left: Bitcoin and $USD.
To the right is a chat box. There are two chat bots, Al1c3 and B0b, which use Gemini's free tier to discuss what's going on in the markets.
Users can chat too, and the bots will react based on the conversation.
There need to be rate limits on everything to keep it completely free.
Focus on the back-end API implementation.
Give me the full output of any changed files.

Help me with this error:

$ mix phx.server
[info] Running CoinTalkWeb.Endpoint with Bandit 1.6.7 at 127.0.0.1:4000 (http)
[info] Access CoinTalkWeb.Endpoint at http://localhost:4000
[info] GET /
[debug] Processing with CoinTalkWeb.PageController.home/2
  Parameters: %{}
  Pipelines: [:browser]
[info] Sent 500 in 62ms
[error] ** (UndefinedFunctionError) function CoinTalkWeb.PageController.init/1 is undefined (module CoinTalkWeb.PageController is not available)
    CoinTalkWeb.PageController.init(:home)
    (phoenix 1.7.19) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5
    (coin_talk 0.1.0) lib/coin_talk_web/endpoint.ex:1: CoinTalkWeb.Endpoint.plug_builder_call/2
    (coin_talk 0.1.0) deps/plug/lib/plug/debugger.ex:136: CoinTalkWeb.Endpoint."call (overridable 3)"/2
    (coin_talk 0.1.0) lib/coin_talk_web/endpoint.ex:1: CoinTalkWeb.Endpoint.call/2
    (phoenix 1.7.19) lib/phoenix/endpoint/sync_code_reload_plug.ex:22: Phoenix.Endpoint.SyncCodeReloadPlug.do_call/4
    (bandit 1.6.7) lib/bandit/pipeline.ex:129: Bandit.Pipeline.call_plug!/2
    (bandit 1.6.7) lib/bandit/pipeline.ex:40: Bandit.Pipeline.run/4
    (bandit 1.6.7) lib/bandit/http1/handler.ex:12: Bandit.HTTP1.Handler.handle_data/3        
    (bandit 1.6.7) lib/bandit/delegating_handler.ex:18: Bandit.DelegatingHandler.handle_data/3
    (bandit 1.6.7) lib/bandit/delegating_handler.ex:8: Bandit.DelegatingHandler.handle_continue/2
    (stdlib 6.2) gen_server.erl:2335: :gen_server.try_handle_continue/3
    (stdlib 6.2) gen_server.erl:2244: :gen_server.loop/7
    (stdlib 6.2) proc_lib.erl:329: :proc_lib.init_p_do_apply/3

[error] Task #PID<0.654.0> started from CoinTalkWeb.Endpoint terminating
** (UndefinedFunctionError) function Tailwind.install_and_run/2 is undefined (module Tailwind is not available). Make sure the module name is correct and has been specified in full (or that an alias has been defined)
    Tailwind.install_and_run(:coin_talk, ["--watch"])
    (phoenix 1.7.19) lib/phoenix/endpoint/watcher.ex:19: Phoenix.Endpoint.Watcher.watch/2    
    (elixir 1.18.2) lib/task/supervised.ex:101: Task.Supervised.invoke_mfa/2
Function: &Phoenix.Endpoint.Watcher.watch/2
    Args: ["tailwind", {Tailwind, :install_and_run, [:coin_talk, ["--watch"]]}]
[error] Task #PID<0.653.0> started from CoinTalkWeb.Endpoint terminating
** (UndefinedFunctionError) function Esbuild.install_and_run/2 is undefined (module Esbuild is not available). Make sure the module name is correct and has been specified in full (or that an alias has been defined)
    Esbuild.install_and_run(:coin_talk, ["--sourcemap=inline", "--watch"])
    (phoenix 1.7.19) lib/phoenix/endpoint/watcher.ex:19: Phoenix.Endpoint.Watcher.watch/2    
    (elixir 1.18.2) lib/task/supervised.ex:101: Task.Supervised.invoke_mfa/2
Function: &Phoenix.Endpoint.Watcher.watch/2
    Args: ["esbuild", {Esbuild, :install_and_run, [:coin_talk, ["--sourcemap=inline", "--watch"]]}]
[error] Task #PID<0.661.0> started from CoinTalkWeb.Endpoint terminating
** (UndefinedFunctionError) function Tailwind.install_and_run/2 is undefined (module Tailwind is not available). Make sure the module name is correct and has been specified in full (or that an alias has been defined)
    Tailwind.install_and_run(:coin_talk, ["--watch"])
    (phoenix 1.7.19) lib/phoenix/endpoint/watcher.ex:19: Phoenix.Endpoint.Watcher.watch/2    
    (elixir 1.18.2) lib/task/supervised.ex:101: Task.Supervised.invoke_mfa/2
Function: &Phoenix.Endpoint.Watcher.watch/2
    Args: ["tailwind", {Tailwind, :install_and_run, [:coin_talk, ["--watch"]]}]
[error] Task #PID<0.662.0> started from CoinTalkWeb.Endpoint terminating
** (UndefinedFunctionError) function Esbuild.install_and_run/2 is undefined (module Esbuild is not available). Make sure the module name is correct and has been specified in full (or that an alias has been defined)
    Esbuild.install_and_run(:coin_talk, ["--sourcemap=inline", "--watch"])
    (phoenix 1.7.19) lib/phoenix/endpoint/watcher.ex:19: Phoenix.Endpoint.Watcher.watch/2    
    (elixir 1.18.2) lib/task/supervised.ex:101: Task.Supervised.invoke_mfa/2
Function: &Phoenix.Endpoint.Watcher.watch/2
    Args: ["esbuild", {Esbuild, :install_and_run, [:coin_talk, ["--sourcemap=inline", "--watch"]]}]
[info] Shutting down 1 sockets in 1 rounds of 2000ms
=== File: lib/coin_talk/application.ex ===

defmodule CoinTalk.Application do
  # See https://hexdocs.pm/elixir/Application.html
  # for more information on OTP Applications
  @moduledoc false

  use Application

  @impl true
  def start(_type, _args) do
    children = [
      CoinTalkWeb.Telemetry,
      CoinTalk.Repo,
      {DNSCluster, query: Application.get_env(:coin_talk, :dns_cluster_query) || :ignore},
      {Phoenix.PubSub, name: CoinTalk.PubSub},
      # Start the Finch HTTP client for sending emails
      {Finch, name: CoinTalk.Finch},
      # Start a worker by calling: CoinTalk.Worker.start_link(arg)
      # {CoinTalk.Worker, arg},
      # Start to serve requests, typically the last entry
      CoinTalkWeb.Endpoint
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: CoinTalk.Supervisor]
    Supervisor.start_link(children, opts)
  end

  # Tell Phoenix to update the endpoint configuration
  # whenever the application is updated.
  @impl true
  def config_change(changed, _new, removed) do
    CoinTalkWeb.Endpoint.config_change(changed, removed)
    :ok
  end
end

=== File: lib/coin_talk/chat/message.ex ===

defmodule CoinTalk.Chat.Message do
    @moduledoc """
    An Ecto schema for chat messages.
    """
  
    use Ecto.Schema
    import Ecto.Changeset
  
    schema "chat_messages" do
      field :sender, :string
      field :content, :string
  
      timestamps()
    end
  
    @doc false
    def changeset(message, attrs) do
      message
      |> cast(attrs, [:sender, :content])
      |> validate_required([:sender, :content])
    end
  end
  
=== File: lib/coin_talk/chat.ex ===

defmodule CoinTalk.Chat do
    @moduledoc """
    The Chat context for storing messages and triggering bot responses.
    """
  
    import Ecto.Query, warn: false
    alias CoinTalk.Repo
    alias CoinTalk.Chat.Message
  
    @doc """
    Lists the most recent chat messages (by default the last 50).
    """
    def list_messages(limit \\ 50) do
      Message
      |> order_by([m], desc: m.inserted_at)
      |> limit(^limit)
      |> Repo.all()
      |> Enum.reverse()
    end
  
    @doc """
    Creates a new chat message.
    """
    def create_message(attrs \\ %{}) do
      %Message{}
      |> Message.changeset(attrs)
      |> Repo.insert()
    end
  
    @doc """
    Handles a user–submitted message and, if successful, triggers bot responses.
    """
    def handle_user_message(attrs) do
      case create_message(attrs) do
        {:ok, message} ->
          # Trigger bot responses asynchronously if the sender is not a bot.
          Task.start(fn -> maybe_trigger_bots(message) end)
          {:ok, message}
  
        error ->
          error
      end
    end
  
    defp maybe_trigger_bots(%Message{sender: sender} = message) do
      if sender not in ["Al1c3", "B0b"] do
        # For demonstration, trigger responses from both bots.
        for bot <- ["Al1c3", "B0b"] do
          prompt = "React to the conversation: #{message.content}"
          case CoinTalk.GeminiClient.generate_content(prompt) do
            {:ok, response} ->
              create_message(%{sender: bot, content: response})
            {:error, _reason} ->
              :noop
          end
        end
      end
    end
  end
  
=== File: lib/coin_talk/repo.ex ===

defmodule CoinTalk.Repo do
  use Ecto.Repo,
    otp_app: :coin_talk,
    adapter: Ecto.Adapters.Postgres
end

=== File: lib/coin_talk.ex ===

defmodule CoinTalk do
  @moduledoc """
  CoinTalk keeps the contexts that define your domain
  and business logic.

  Contexts are also responsible for managing your data, regardless
  if it comes from the database, an external API or others.
  """
end

=== File: lib/coin_talk_web/controllers/api/chart_controller.ex ===

defmodule CoinTalkWeb.Api.ChartController do
    @moduledoc """
    A JSON API for returning (simulated) chart data.
    """
    use CoinTalkWeb, :controller
  
    @doc """
    Returns current market data for Bitcoin and USD.
  
    (For demo purposes the prices are randomized.)
    """
    def index(conn, _params) do
      data = %{
        bitcoin: %{price: random_price(30000, 60000)},
        usd: %{exchange_rate: random_price(0.8, 1.2)}
      }
  
      json(conn, data)
    end
  
    defp random_price(min, max) do
      (:rand.uniform() * (max - min) + min)
      |> Float.round(2)
    end
  end
  
=== File: lib/coin_talk_web/controllers/api/chat_controller.ex ===

defmodule CoinTalkWeb.Api.ChatController do
    @moduledoc """
    A JSON API for retrieving and creating chat messages.
    """
    use CoinTalkWeb, :controller
  
    alias CoinTalk.Chat
  
    @doc """
    Lists recent chat messages.
    """
    def index(conn, _params) do
      messages = Chat.list_messages()
      json(conn, %{messages: messages})
    end
  
    @doc """
    Creates a new chat message.
  
    Expects a JSON payload with at least “sender” and “content” keys.
    """
    def create(conn, %{"sender" => _sender, "content" => _content} = params) do
      case Chat.handle_user_message(params) do
        {:ok, message} ->
          json(conn, %{message: message})
  
        {:error, changeset} ->
          conn
          |> put_status(:unprocessable_entity)
          |> json(%{errors: traverse_errors(changeset)})
      end
    end
  
    defp traverse_errors(changeset) do
      Ecto.Changeset.traverse_errors(changeset, fn {msg, _opts} -> msg end)
    end
  end
  
=== File: lib/coin_talk_web/controllers/default_controller.ex ===

# lib/coin_talk_web/controllers/default_controller.ex
defmodule CoinTalkWeb.DefaultController do
  use CoinTalkWeb, :controller

  def index(conn, _params) do
    json(conn, %{
      message: "Welcome to Coin Talk",
      version: "1.0"
    })
  end
end

=== File: lib/coin_talk_web/endpoint.ex ===

defmodule CoinTalkWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :coin_talk

  # The session will be stored in the cookie and signed,
  # this means its contents can be read but not tampered with.
  # Set :encryption_salt if you would also like to encrypt it.
  @session_options [
    store: :cookie,
    key: "_coin_talk_key",
    signing_salt: "AaW+KOxB",
    same_site: "Lax"
  ]

  socket "/live", Phoenix.LiveView.Socket,
    websocket: [connect_info: [session: @session_options]],
    longpoll: [connect_info: [session: @session_options]]

  # Serve at "/" the static files from "priv/static" directory.
  #
  # You should set gzip to true if you are running phx.digest
  # when deploying your static files in production.
  plug Plug.Static,
    at: "/",
    from: :coin_talk,
    gzip: false,
    only: CoinTalkWeb.static_paths()

  # Code reloading can be explicitly enabled under the
  # :code_reloader configuration of your endpoint.
  if code_reloading? do
    socket "/phoenix/live_reload/socket", Phoenix.LiveReloader.Socket
    plug Phoenix.LiveReloader
    plug Phoenix.CodeReloader
    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :coin_talk
  end

  plug Phoenix.LiveDashboard.RequestLogger,
    param_key: "request_logger",
    cookie_key: "request_logger"

  plug Plug.RequestId
  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

  plug Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: ["*/*"],
    json_decoder: Phoenix.json_library()

  plug Plug.MethodOverride
  plug Plug.Head
  plug Plug.Session, @session_options
  plug CoinTalkWeb.Router
end

=== File: lib/coin_talk_web/gettext.ex ===

defmodule CoinTalkWeb.Gettext do
  @moduledoc """
  A module providing Internationalization with a gettext-based API.

  By using [Gettext](https://hexdocs.pm/gettext),
  your module gains a set of macros for translations, for example:

      import CoinTalkWeb.Gettext

      # Simple translation
      gettext("Here is the string to translate")

      # Plural translation
      ngettext("Here is the string to translate",
               "Here are the strings to translate",
               3)

      # Domain-based translation
      dgettext("errors", "Here is the error message to translate")

  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.
  """
  use Gettext.Backend, otp_app: :coin_talk
end

=== File: lib/coin_talk_web/plugs/rate_limiter.ex ===

defmodule CoinTalkWeb.Plugs.RateLimiter do
    @moduledoc """
    A simple ETS–based rate limiter plug.
  
    For each incoming API request the plug will inspect the caller’s IP address
    (as determined from `conn.remote_ip`) and allow at most @limit requests per @interval.
    If the rate is exceeded a 429 status is returned.
    """
  
    import Plug.Conn
  
    @limit 60            # maximum requests allowed per interval
    @interval 60_000     # interval in milliseconds (60 seconds)
  
    def init(opts), do: opts
  
    def call(conn, _opts) do
      ensure_table_exists()
      ip = ip_to_string(conn.remote_ip)
      now = System.system_time(:millisecond)
  
      case check_rate(ip, now) do
        :ok ->
          conn
  
        :error ->
          conn
          |> send_resp(429, "Rate limit exceeded")
          |> halt()
      end
    end
  
    defp ip_to_string(remote_ip) when is_tuple(remote_ip) do
      remote_ip
      |> Tuple.to_list()
      |> Enum.join(".")
    end
  
    defp ensure_table_exists do
      table = :rate_limiter_table
  
      # Create the table if it does not already exist.
      if :ets.whereis(table) == :undefined do
        :ets.new(table, [:named_table, :public, read_concurrency: true])
      end
  
      :ok
    end
  
    defp check_rate(ip, now) do
      table = :rate_limiter_table
  
      case :ets.lookup(table, ip) do
        [] ->
          :ets.insert(table, {ip, 1, now})
          :ok
  
        [{^ip, count, timestamp}] ->
          if now - timestamp < @interval do
            if count < @limit do
              :ets.insert(table, {ip, count + 1, timestamp})
              :ok
            else
              :error
            end
          else
            # Reset the counter if the interval has passed.
            :ets.insert(table, {ip, 1, now})
            :ok
          end
      end
    end
  end
  
=== File: lib/coin_talk_web/router.ex ===

defmodule CoinTalkWeb.Router do
  use CoinTalkWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {CoinTalkWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
    plug CoinTalkWeb.Plugs.RateLimiter
  end

  scope "/", CoinTalkWeb do
    pipe_through :browser

    get "/", PageController, :home
  end

  # API endpoints for chart data and chat messages.
  scope "/api", CoinTalkWeb.Api, as: :api do
    pipe_through :api

    get "/charts", ChartController, :index
    resources "/chat", ChatController, only: [:index, :create]
  end

  # Enable LiveDashboard and Swoosh mailbox preview in development
  if Application.compile_env(:coin_talk, :dev_routes) do
    import Phoenix.LiveDashboard.Router

    scope "/dev" do
      pipe_through :browser

      live_dashboard "/dashboard", metrics: CoinTalkWeb.Telemetry
      forward "/mailbox", Plug.Swoosh.MailboxPreview
    end
  end
end

=== File: lib/coin_talk_web/telemetry.ex ===

defmodule CoinTalkWeb.Telemetry do
  use Supervisor
  import Telemetry.Metrics

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    children = [
      # Telemetry poller will execute the given period measurements
      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
      # Add reporters as children of your supervision tree.
      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  def metrics do
    [
      # Phoenix Metrics
      summary("phoenix.endpoint.start.system_time",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.endpoint.stop.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.start.system_time",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.exception.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.stop.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.socket_connected.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_joined.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_handled_in.duration",
        tags: [:event],
        unit: {:native, :millisecond}
      ),

      # Database Metrics
      summary("coin_talk.repo.query.total_time",
        unit: {:native, :millisecond},
        description: "The sum of the other measurements"
      ),
      summary("coin_talk.repo.query.decode_time",
        unit: {:native, :millisecond},
        description: "The time spent decoding the data received from the database"
      ),
      summary("coin_talk.repo.query.query_time",
        unit: {:native, :millisecond},
        description: "The time spent executing the query"
      ),
      summary("coin_talk.repo.query.queue_time",
        unit: {:native, :millisecond},
        description: "The time spent waiting for a database connection"
      ),
      summary("coin_talk.repo.query.idle_time",
        unit: {:native, :millisecond},
        description:
          "The time the connection spent waiting before being checked out for the query"
      ),

      # VM Metrics
      summary("vm.memory.total", unit: {:byte, :kilobyte}),
      summary("vm.total_run_queue_lengths.total"),
      summary("vm.total_run_queue_lengths.cpu"),
      summary("vm.total_run_queue_lengths.io")
    ]
  end

  defp periodic_measurements do
    [
      # A module, function and arguments to be invoked periodically.
      # This function must call :telemetry.execute/3 and a metric must be added above.
      # {CoinTalkWeb, :count_users, []}
    ]
  end
end

=== File: lib/coin_talk_web.ex ===

defmodule CoinTalkWeb do
  @moduledoc """
  The entrypoint for defining your web interface, such
  as controllers, components, channels, and so on.

  This can be used in your application as:

      use CoinTalkWeb, :controller
      use CoinTalkWeb, :html

  The definitions below will be executed for every controller,
  component, etc, so keep them short and clean, focused
  on imports, uses and aliases.

  Do NOT define functions inside the quoted expressions
  below. Instead, define additional modules and import
  those modules here.
  """

  def static_paths, do: ~w(assets fonts images favicon.ico robots.txt)

  def router do
    quote do
      use Phoenix.Router, helpers: false

      # Import common connection and controller functions to use in pipelines
      import Plug.Conn
      import Phoenix.Controller
      import Phoenix.LiveView.Router
    end
  end

  def channel do
    quote do
      use Phoenix.Channel
    end
  end

  def controller do
    quote do
      use Phoenix.Controller,
        formats: [:html, :json],
        layouts: [html: CoinTalkWeb.Layouts]

      import Plug.Conn
      import CoinTalkWeb.Gettext

      unquote(verified_routes())
    end
  end

  def live_view do
    quote do
      use Phoenix.LiveView,
        layout: {CoinTalkWeb.Layouts, :app}

      unquote(html_helpers())
    end
  end

  def live_component do
    quote do
      use Phoenix.LiveComponent

      unquote(html_helpers())
    end
  end

  def html do
    quote do
      use Phoenix.Component

      # Import convenience functions from controllers
      import Phoenix.Controller,
        only: [get_csrf_token: 0, view_module: 1, view_template: 1]

      # Include general helpers for rendering HTML
      unquote(html_helpers())
    end
  end

  defp html_helpers do
    quote do
      # HTML escaping functionality
      import Phoenix.HTML
      # Core UI components and translation
      import CoinTalkWeb.CoreComponents
      import CoinTalkWeb.Gettext

      # Shortcut for generating JS commands
      alias Phoenix.LiveView.JS

      # Routes generation with the ~p sigil
      unquote(verified_routes())
    end
  end

  def verified_routes do
    quote do
      use Phoenix.VerifiedRoutes,
        endpoint: CoinTalkWeb.Endpoint,
        router: CoinTalkWeb.Router,
        statics: CoinTalkWeb.static_paths()
    end
  end

  @doc """
  When used, dispatch to the appropriate controller/live_view/etc.
  """
  defmacro __using__(which) when is_atom(which) do
    apply(__MODULE__, which, [])
  end
end

=== File: lib/gemini_client.ex ===

defmodule CoinTalk.GeminiClient do
  @moduledoc """
  Client for interacting with Google's Gemini API.
  """

  @api_url "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent"

  def generate_content(prompt) do
    case System.get_env("GEMINI_API_KEY") do
      nil ->
        {:error, "Missing GEMINI_API_KEY environment variable"}

      api_key ->
        body = %{
          "contents" => [%{"parts" => [%{"text" => prompt}]}]
        }

        headers = [{"Content-Type", "application/json"}]

        case Req.post(@api_url <> "?key=" <> api_key, json: body, headers: headers) do
          {:ok, %Req.Response{
            status: 200,
            body: %{"candidates" => [%{"content" => %{"parts" => [%{"text" => response}]}}]}
          }} ->
            {:ok, response}

          {:ok, %Req.Response{status: status, body: body}} ->
            {:error, "Request failed: #{status}, #{inspect(body)}"}

          {:error, reason} ->
            {:error, "Request error: #{inspect(reason)}"}
        end
    end
  end
end

=== File: mix.exs ===

defmodule CoinTalk.MixProject do
  use Mix.Project

  def project do
    [
      app: :coin_talk,
      version: "0.1.0",
      elixir: "~> 1.14",
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps()
    ]
  end

  # Configuration for the OTP application.
  #
  # Type `mix help compile.app` for more information.
  def application do
    [
      mod: {CoinTalk.Application, []},
      extra_applications: [:logger, :runtime_tools]
    ]
  end

  # Specifies which paths to compile per environment.
  defp elixirc_paths(:test), do: ["lib", "test/support"]
  defp elixirc_paths(_), do: ["lib"]

  # Specifies your project dependencies.
  #
  # Type `mix help deps` for examples and options.
  defp deps do
    [
      {:phoenix, "~> 1.7.14"},
      {:phoenix_ecto, "~> 4.5"},
      {:ecto_sql, "~> 3.10"},
      {:postgrex, ">= 0.0.0"},
      {:phoenix_html, "~> 4.1"},
      {:phoenix_live_reload, "~> 1.2", only: :dev},
      {:phoenix_live_view, "~> 1.0.0-rc.1", override: true},
      {:phoenix_live_dashboard, "~> 0.8.3"},
      {:swoosh, "~> 1.5"},
      {:finch, "~> 0.13"},
      {:telemetry_metrics, "~> 1.0"},
      {:telemetry_poller, "~> 1.0"},
      {:gettext, "~> 0.20"},
      {:jason, "~> 1.2"},
      {:dns_cluster, "~> 0.1.1"},
      {:bandit, "~> 1.5"},
      {:req, "~> 0.5.8"},
      {:dotenv_parser, "~> 2.0"}
    ]
  end
  

  # Aliases are shortcuts or tasks specific to the current project.
  # For example, to install project dependencies and perform other setup tasks, run:
  #
  #     $ mix setup
  #
  # See the documentation for `Mix` for more info on aliases.
  defp aliases do
    [
      setup: ["deps.get", "ecto.setup"],
      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
      "ecto.reset": ["ecto.drop", "ecto.setup"],
      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"]
    ]
  end
  
end

=== File: priv/repo/migrations/20250210233227_create_chat_messages.exs ===

defmodule CoinTalk.Repo.Migrations.CreateChatMessages do
  use Ecto.Migration

  def change do
    create table(:chat_messages) do
      add :sender, :string, null: false
      add :content, :text, null: false

      timestamps()
    end
  end
end

=== File: priv/repo/seeds.exs ===

# Script for populating the database. You can run it as:
#
#     mix run priv/repo/seeds.exs
#
# Inside the script, you can read and write to any of your
# repositories directly:
#
#     CoinTalk.Repo.insert!(%CoinTalk.SomeSchema{})
#
# We recommend using the bang functions (`insert!`, `update!`
# and so on) as they will fail if something goes wrong.
